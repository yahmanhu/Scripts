#!/bin/bash
# Simple note taking script

diane_file=~/diane
date=$(date +"<%m-%d-%Y-%H:%M:%S>")
IFS=$'\n'

normal=$'\e[8m'
bold=$'\e[1m'
italic=$'\e[3m'
underlined=$'\e[4m'
inverted=$'\e[7m'
blink=$'\e[5m'
reset=$'\e[0m'

green=$'\e[32m'
red=$'\e[31m'
yellow=$'\e[33m'
blue=$'\e[34m'
red=$'\e[31m'
cyan=$'\e[36m'
magenta=$'\e[35m'
gray=$'\e[37m'
dark_gray=$'\e[90m'
white=$'\e[97m'

label_color=$green
label_format=$bold$inverted

DONE="@done"
message="There is no task to show."
show_finished_task="true"

create_diane(){

    touch $diane_file
    echo "$diane_file created"
}

show_finished_tasks(){

    finished=$(grep "$DONE" $diane_file)

    if [[ -z $finished ]]; then

        echo -e "There is no finished task yet."

    else

         grep "$DONE" $diane_file  | awk '{$1="[3m"$1; $2=$2"[0m[3m"; print $0}' 

    fi


}

read_diane(){

    if [[ $show_finished_task == "true" ]]; then
        
        sed "/$DONE/d" $diane_file
        echo -e "\n$italic"Finished"$reset"
        grep "$DONE" $diane_file  | awk '{$1="[3m"$1; $2=$2"[0m[3m"; print $0}' 

    elif [[ $show_finished_task == "false" ]]; then
        
        sed "/$DONE/d" $diane_file

    fi

}

edit_diane(){

    $EDITOR $diane_file

}

clear_diane(){

    sed -i "/.*/d" $diane_file

}
remove_diane(){

    rm $diane_file

}

add_new_task(){

    echo -e $date $input >> $diane_file

}

add_new_task_with_label(){

    case $label in

        note) label_format=$inverted$bold ; label_color=$white;;
        diane) label_format=$inverted$bold ; label_color=$green;;
        *) label_format=$label_format ; label_color=$label_color

    esac
    
    label=$(echo $label | awk '{print toupper($0)}')
    echo -e $date $label $input >> $diane_file
    sed -i -e s"/$label/$label_format$label_color$label$reset/" $diane_file

}


filter_label(){

        readarray content_array < $diane_file
        labels=()
        
        for lines in ${content_array[@]}; do

            if [[ $lines == *"["* ]]; then

                labels+=($lines)
            fi
        done

        printf '%s\n' "${labels[@]}" | grep -i $filter

}

flag_finished_task(){

    while true; do
    readarray content_array < $diane_file

    unfinished_tasks=()

    for lines in ${content_array[@]}; do

        if [[ $lines != *"$DONE"* ]]; then

            unfinished_tasks+=($lines)

        fi

        done

    if (( "${#unfinished_tasks[@]}" == 0 )); then

        echo -e "Every task are finished."
        break 2

        fi

        for selected_task in ${!unfinished_tasks[@]}; do
            echo $green$bold$selected_task$reset ${unfinished_tasks[$selected_task]}
        done

    read task_index

    if [[ $task_index =~ ^[0-9]+$ ]] && (( $task_index < ${#unfinished_tasks[@]} )); then

        selected_task=${unfinished_tasks[$task_index]}

        echo -e $selected_task @done $reset"\n"

        if [[ $selected_task == *"["* ]]; then

            replace_task=$(echo $selected_task | sed "s/\^/\\\^/g;s/\[/\\\[/g")

        else

        replace_task=$(echo -e $selected_task)

    fi

        sed -i s"/$replace_task/& $DONE/" "$diane_file"

    elif [[ $task_index =~ ^[0-9]+$ ]] && (( $task_index == ${#unfinished_tasks[@]} )); then

        echo "not a valid index"

    elif [[ $task_index == "q" ]] || [[ $task_index == "Q" ]]; then

        break

    else

        echo "not a valid index"

    fi

done

}

unflag_finished_task(){

    while true; do
    readarray content_array < $diane_file

    finished_tasks=()

    for lines in ${content_array[@]}; do

        if [[ $lines == *"$DONE"* ]]; then

            finished_tasks+=($lines)

        fi

        done

    if (( "${#finished_tasks[@]}" == 0 )); then

        echo -e "There is no finished task yet."
        break 2

        fi

        for selected_task in ${!finished_tasks[@]}; do
            echo $yellow$bold$selected_task$reset ${finished_tasks[$selected_task]}
        done

    read task_index

    if [[ $task_index =~ ^[0-9]+$ ]] && (( $task_index < ${#finished_tasks[@]} )); then

        selected=${finished_tasks[$task_index]}

        if [[ $selected == *"["* ]]; then

            echo -e flag removed: "$selected"

            selected=$(echo $selected | sed "s/\^/\\\^/g;s/\[/\\\[/g")

            replace_task=${selected% $DONE}

        else

        replace_task=${selected% $DONE}
        echo -e flag removed: "$replace_task"

        fi

        sed -i s"/$selected/$replace_task/" "$diane_file"

        echo -e "\n"

    elif [[ $task_index =~ ^[0-9]+$ ]] && (( $task_index == ${#finished_tasks[@]} )); then

        echo "not a valid index"

    elif [[ $task_index == "q" ]] || [[ $task_index == "Q" ]]; then

        break

    else

        echo "not a valid index"

    fi

done

}

remove_finished_tasks(){

    sed -i "/$DONE/d" $diane_file

}

remove_task(){

    while true; do

    readarray content_array < $diane_file

    if [[ ${content_array[@]} > 0 ]]; then

        for tasks in ${!content_array[@]}; do

            echo -e $bold$red$tasks$reset ${content_array[$tasks]}

        done

    else

        echo $message
        break

    fi

    read task_index

    if [[ $task_index =~ ^[0-9]+$ ]] && (( $task_index < ${#content_array[@]} )); then

        selected_task=${content_array[$task_index]}

        echo -e removed: "$selected_task"

        if [[ $selected_task == *"["* ]]; then

            remove_task=$(echo $selected_task | sed "s/\^/\\\^/g;s/\[/\\\[/g")

        else

        remove_task=$(echo -e $selected_task)

        fi

        sed -i "/$remove_task/d" $diane_file

    elif [[ $task_index =~ ^[0-9]+$ ]] && (( $task_index == ${#content_array[@]} )); then

        echo "not a valid index"

    elif [[ $task_index == "q" ]] || [[ $task_index == "Q" ]]; then

        break

    else

        echo "not a valid index"

    fi
done

}

help(){

cat << EOF

To add tasks/notes, use 'diane' command and type your task/note without any option.
To print your tasks/notes, use simply 'diane' command without any further options. If file > $diane_file < does not exist then it will be created first.
If 'show_finished_task' variable set true in the script, then it will print every tasks. If 'show_finished_task' variable is false, then it will print only pending tasks.

Options:

        -clr    -- remove all content from file
        -e      -- edit file
        -r      -- remove file
        -ff     -- selec task and flag it as finished (@done) in file. To exit from loop, type 'q' or 'Q' then press 'Return'
        -uf     -- select task and remove flag (@done) in file. To exit from loop, type 'q' or 'Q' then press 'Return'
        -sf     -- show only finished/flagged (@done) tasks
        -rf     -- remove all finished/flagged (@done) tasks from file 
        -rt     -- remove selected task from file. To exit from loop, type 'q' or 'Q' then press 'Return'
        -l      -- add label to note. You must write your note after the label between 'single quotes' or "double quotes" 
        -fl     -- filter labels
        -h      -- show this help page

EOF

}

whoami(){

echo -e Diane is a mysterious woman Dale Cooper addresses all of his tapes to in the American television serial drama "$italic"Twin Peaks$reset."\n"See: http://twinpeaks.wikia.com/wiki/Diane

}

case $1 in

    "") 
        if [[ -e $diane_file ]]; then

            if [[ -s $diane_file ]]; then

                read_diane

            else

                echo $message

            fi

        else

            create_diane
        fi
        
        ;;

    -clr) clear_diane;;
    -e) edit_diane;;
    -r) remove_diane;;
    -ff) flag_finished_task;;
    -uf) unflag_finished_task;;
    -sf) show_finished_tasks;;
    -rf) remove_finished_tasks;;
    -rt) remove_task;;
    -l) label=$2 ; input=$3 add_new_task_with_label;;
    -fl) filter=$2 filter_label;;
    -whoami) whoami;;
    -h) help;;
    *) input=$@ add_new_task;;

esac
