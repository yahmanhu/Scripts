#!/bin/bash
# Select media (video) file from dmenu and play it with mpv
# Download subtitle automatically requires periscope (https://github.com/patrickdessalle/periscope)

# Base directory where script search for .mkv, .mp4 and .srt files
dir=~/downloads
# Journal file to keep tracking what and when you watched
journal=~/dmw_journal
# Use periscope (yes or no)?
use_periscope="yes"
# Date format for journaling
date=$(date +"%m-%d-%Y-%H:%M")
# Set dmenu font
dmenu_font='monospace-12'

# Find .mkv, .mp4 and .srt files
find_mkv_files(){ find $dir -iname "*.mkv";}
find_mp4_files(){ find $dir -iname "*.mp4";}
find_srt_files(){ find $dir -iname "*.srt";}
# Find .srt files for the selected media file in it's own directory by changing file extension during find
find_mp4_srt(){ find "$selected_file_dir" -iname ${file_name%.mp4}.srt;}
find_mkv_srt(){ find "$selected_file_dir" -iname ${file_name%.mkv}.srt;}
# Find media files and slice the path leaving only the file names and their extensions
file_names(){
    # Check if journal file exist to avoid grep error message
    if [[ ! -e $journal ]]; then
        touch $journal
    fi
    File_Names=$( ( find_mkv_files  && find_mp4_files ) | awk -F "/" '{print $NF}')
    for i in $File_Names; do
        # If file name is in the journal file (if it's watched) then mark it with an * symbol
        if grep -q "$i" "$journal"; then
            i=${i//*/\*$i}
        fi
        echo $i
    done
}
# Write selected file's name into journal file and play it with mpv
play(){ echo $date $file_name >> $journal ; mpv "$selected_file"; }

# Print file names into dmenu
file_name=$( file_names | sort | dmenu -i -l 20 -fn $dmenu_font )

case $file_name in

    # If no file selected, then exit the program
    "") exit;;
    # If filename contains brackets, then escape them with sed
    *) if [[ "$file_name" == *[\[\]]* ]]; then file_name=$(sed 's/\[/\\[/g;s/\]/\\]/g' <<< $file_name) ; fi
        if [[ "$file_name" =~ " " ]]; then file_name=$(sed 's/ /\ /g' <<< $file_name) ; fi;;

esac

# Get the selected file's complete path
selected_file=$(find -iname "$file_name")
# Get the path of the directory that contains the selected file
selected_file_dir=$(echo "$selected_file" | awk -F "/" 'BEGIN{OFS="/"} {$NF=""; print $0}')

# If no subtitle (.srt) file for the selected file
# Check if we want to use periscope (if use_periscope variable is "yes")
if [[ $use_periscope == "yes" ]]; then
    if [[ ! -e $(find_mkv_srt) ]] && [[ ! -e $(find_mp4_srt) ]]; then
        # Ask for download
        subtitle=$(echo -e "yes\nno" | dmenu -p "Download subtitle before start?" -i -fn $dmenu_font)

        case $subtitle in
            # If answer is yes, then inform user via dmenu and try to download subtitle with periscope
            yes) dmenu -p "Downloading subtitle..." -i -l 1 -fn $dmenu_font  &

                # Kill dmenu after 2 seconds, because we use it just as a feedback
                if pgrep "dmenu" > /dev/null;then
                    sleep 2
                    pkill dmenu
                # Download subtitle with periscope (-l means language)
                fi && periscope -l en $(find $dir -iname $file_name)

                # If periscope can't find subtitle to download, then ask if we want to play the selected file or not
                if [[ $? -ne 0 ]]; then subtitle_error=$(echo -e "yes\nno"  |  dmenu -p "Can't find subtitle. Play anyway?" -i -fn $dmenu_font)

                    case $subtitle_error in
                        yes) play;;
                        no) exit;;
                    esac

                else
                    play
                fi
                 ;;

            # If we don't want to download subtitle file, then play instantly
            no) play ;;
        esac

    # If there's already a subtitle for the selected file, then play instantly
    else
        play
    fi
# If we don't want to use periscope (if use_periscope variable is "no"), then play immediately
else
    play
fi
